---
output: 
    pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Given data

**Shift**

| shift_id | deliverer_id | shift_start_time | shift_end_time | total_pay | number_of_deliveries |
|---------|---------------|------------------|----------------|-----------|----------------------|
| 1235    | 6745          | 2/29/16 7:00     | 2/29/16 9:40   | 46.78     | 9                    |


**Deliverer**

| id   | email_address | zipcode | submarket_id |
|------|---------------|---------|--------------|
| 6745 | hi@hello.com  | 12345   | 2            |


# Tasks

**1. Write a query to calculate the average earnings per hour by day of week.**

The `Shift` and `Deliverer` tables do not include the exact details of each delivery (i.e., when the delivery was made, what the earning was from that delivery) so I'll assume that deliveries are evenly distributed in time and pay during the period of time the deliverer is online. Under this assumption, the earnings for 7pm, 8pm, and 9pm are assumed to be equal to $\frac{total\ pay}{hours\ worked} = \frac{46.78}{2.667} = 17.54$ dollars.

Next, I'd transform the data such that each hour is its own row. That is, I'd convert the sample row:

| shift_id | deliverer_id | shift_start_time | shift_end_time | total_pay | number_of_deliveries |
|----------|--------------|------------------|-------------=--|-----------|----------------------|
| 1235     | 6745         | 2/29/16 7:00     | 2/29/16 9:40   | 46.78     | 9                    |

into the following "long" format:

| shift_id | deliverer_id | hour | weekday | date       | total_pay |
|----------|--------------|------|---------|------------|-----------|
| 1235     | 6745         | 7:00 | Monday  | 2016-02-29 | 17.54     |
| 1235     | 6745         | 8:00 | Monday  | 2016-02-29 | 17.54     |
| 1235     | 6745         | 9:00 | Monday  | 2016-02-29 | 17.54     |

I'd then group the data by `weekday` and `hour` to compute the mean earnings taking into account all `shift_id`s and `deliverer_id`s.

Below is an implementation of this ETL job in R. The transformed table would be loaded onto the database as a table called `Shift_long`:

```{r, eval = FALSE}
# ---------------------------------------------------------------------------------------
# 1. EXTRACT
# 
# ASSUMPTIONS: database credentials, loading the whole `Shift` table is appropriate (e.g.,
# manageable size due  to the `Shift` table being updated monthly, weekly, daily, hourly,
# by region, etc.)
# ---------------------------------------------------------------------------------------
# library(DBI)
# con <- dbConnect(RMySQL::MySQL(),
#                  dbname = "dbname",
#                  host = "host",
#                  port = 234,
#                  user = "username",
#                  password = "password")
# 
# delivery <- dbGetQuery(con, '
#                    SELECT "shift_id", "deliverer_id", "shift_start_time", 
#                           "shift_end_time","total_pay"
#                    FROM "Shift"
#                    ')

# ---------------------------------------------------------------------------------------
# 2. TRANFORM
#
# ASSUMPTIONS: hours are in military time (i.e., 0 - 23), no deliverer works more than
# 24 hours per shift
# ---------------------------------------------------------------------------------------
# library(tidyverse)

for (shift in list(shift_test, shift_test2)) {
  shift_id <- unique(shift$shift_id)
  deliverer_id <- unique(shift$deliverer_id)
  
  to_upload <- data_frame()
  
  for (work_sesh in shift_id) {
    for (worker in deliverer_id) {
      # Obtaining data for each shift for each deliverer
      dat2 <- shift %>% filter(shift_id == work_sesh, deliverer_id == worker) %>%
        mutate(shift_end_time = as.POSIXct(strptime(shift_end_time, "%m/%d/%y %H:%M")),
               shift_start_time = as.POSIXct(strptime(shift_start_time, "%m/%d/%y %H:%M")))
      if (nrow(dat2) > 0) {
        hourly_earnings = dat2$total_pay /
          as.numeric(dat2$shift_end_time - dat2$shift_start_time)
        
        # If deliverer doesn't work through midnight
        if (hour(dat2$shift_start_time) < hour(dat2$shift_end_time)) {
          hour <- hour(dat2$shift_start_time):hour(dat2$shift_end_time)
          weekday <- rep(weekdays(dat2$shift_start_time, length(hour)))
          date <- rep(as.Date(dat2$shift_start_time), length(hour))
        }
        
        # If deliverer works through midnight
        else {
          before_midnight <- hour(dat2$shift_start_time):23
          after_midnight <- 0:hour(dat2$shift_end_time)
          hour <- c(before_midnight, after_midnight)
          weekday <- c(rep(weekdays(dat2$shift_start_time), length(before_midnight)),
                       rep(weekdays(dat2$shift_end_time), length(after_midnight)))
          date <- c(rep(as.Date(dat2$shift_start_time, "ymd"), length(before_midnight)),
                    rep(as.Date(dat2$shift_end_time, "ymd"), length(after_midnight)))
        }
        
        # Per shift_id and deliverer_id combination
        temp <- data_frame(shift_id = rep(shift_id, length(hour)),
                           deliverer_id = rep(deliverer_id, length(hour)),
                           hour = hour,
                           weekday = weekday,
                           date = date,
                           earnings = rep(hourly_earnings, length(hour)))
        
        # Combine all shift_id and deliverer_id
        to_upload <- rbind(to_upload, temp)
      }
    }
  }
  print(to_upload)
}

# ---------------------------------------------------------------------------------------
# 3. LOAD

# ASSUMPTION: replacing table is more appropriate than appending to existing table.
# ---------------------------------------------------------------------------------------
dbWriteTable(con, "Shift_long", to_upload, overwrite = TRUE)
```

Using the new `Shift` table, I can use the following SQL query to calculate the average earnings per hour by day of week:

```
SELECT hour, weekday, AVG(earnings) AS avg_earnings
FROM Shift_long
GROUP_BY hour, weekday;
```

**2. Please write a query to calculate the average earnings per hour during lunch (11am-2pm) in submarket_id 3.**

The newly created `Shift_long` table can be joined with the given `Deliverer` table to calculate the average earnings per hour during lunch in `submarket_id = 3`:

```
SELECT 
dl.hour,
AVG(dl.earnings) AS avg_earnings,
d.submarket_id
FROM 
Shift_long dl LEFT JOIN
Deliverer d ON dl.deliverer_id = d.id
GROUP_BY
dl.hour
WHERE
dl.hour >= 11 AND
dl.hour <= 14 AND
d.submarket_id = 3;
```

**3. Target deliverers who are in the bottom 50th percentile of total pay per hour in the last 30 days with a promotion. Please write a query to identify who these deliverers are along with their email address.**

First, order deliverers in ascending order by hourly wage in the last 30 days, then select the top 50 percent of this list:

```
SELECT
email_address,
id
FROM (
SELECT
TOP 50 PERCENT *
FROM (
SELECT
d.email_address,
d.id,
AVG(dl.earnings) AS avg_earnings
FROM
Shift_long dl LEFT JOIN
Deliverer d ON dl.deliverer_id  = d.id
GROUP BY
dl.deliverer_id
WHERE
DATEDIFF(day, dl.date, GETDATE()) < 31
ORDER BY avg_earnings ASC
)
);
```
